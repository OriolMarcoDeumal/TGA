int main(int argc, char** argv) {
    if (argc != 3) {
        cout << "Usage: " << argv[0] << " <input_file> <output_file>" << endl;
        return (-1);
    }

    char* fileIN = argv[1];
    char* fileOUT = argv[2];

    // Load image
    int width, height, channels;
    unsigned char* image = stbi_load(fileIN, &width, &height, &channels, 0);
    if (!image) {
        fprintf(stderr, "Couldn't load image.\n");
        return (-1);
    }

    // Allocate pinned memory on the host
    unsigned char* h_image;
    cudaMallocHost((void **)&h_image, width * height * channels * sizeof(unsigned char));
    memcpy(h_image, image, width * height * channels * sizeof(unsigned char));

    // Allocate memory on the GPU
    unsigned char* d_image;
    cudaMalloc((void **)&d_image, width * height * channels * sizeof(unsigned char));
    cudaMemcpy(d_image, h_image, width * height * channels * sizeof(unsigned char), cudaMemcpyHostToDevice);

    // Define grid and block dimensions
    dim3 block_dim(256, 1, 1);
    dim3 grid_dim((width * height * channels + block_dim.x - 1) / block_dim.x, 1, 1);

    // Create histogram
    int* histogram;
    cudaMallocManaged(&histogram, 256 * sizeof(int));
    cudaMemset(histogram, 0, 256 * sizeof(int));

    // Convert the image from RGB to YCbCr
    ycbcr_kernel<<<grid_dim, block_dim>>>(d_image, width, height, channels, /*toYCbCr=*/true);
    cudaDeviceSynchronize();
    CheckCudaError((char *)"Error converting image to YCbCr", __LINE__);

    // Execute kernel to create histogram
    histogram_kernel<<<grid_dim, block_dim>>>(d_image, histogram, width, height, channels);
    cudaDeviceSynchronize();
    CheckCudaError((char *)"Error creating histogram", __LINE__);

    // Calculate accumulated histogram
    int* histogram_accumulated;
    cudaMallocManaged(&histogram_accumulated, 256 * sizeof(int));
    cudaMemset(histogram_accumulated, 0, 256 * sizeof(int));
    int sum = 0;
    for (int i = 0; i < 256; i++) {
        sum += histogram[i];
        histogram_accumulated[i] = sum;
    }

    CheckCudaError((char *)"Error calculating accumulated histogram", __LINE__);

    // Create equalized histogram array
    int* histogram_equalized;
    cudaMallocManaged(&histogram_equalized, 256 * sizeof(int));
    cudaMemset(histogram_equalized, 0, 256 * sizeof(int));
    for (int i = 0; i < 256; i++) {
        histogram_equalized[i] = (int) (255.0f * histogram_accumulated[i] / (width * height));
    }

    CheckCudaError((char *)"Error creating equalized histogram", __LINE__);

    // Execute kernel to equalize image
    equalize_kernel<<<grid_dim, block_dim>>>(d_image, histogram_equalized, width, height, channels);
    cudaDeviceSynchronize();
    CheckCudaError((char *)"Error executing equalization kernel", __LINE__);

    // Convert the image from YCbCr to RGB
    ycbcr_kernel<<<grid_dim, block_dim>>>(d_image, width, height, channels, /*toYCbCr=*/false);
    cudaDeviceSynchronize();
    CheckCudaError((char *)"Error converting image to RGB", __LINE__);

    // Transfer image from GPU to CPU
    cudaMemcpy(h_image, d_image, width * height * channels * sizeof(unsigned char), cudaMemcpyDeviceToHost);

    // Save resulting image
    stbi_write_png(fileOUT, width, height, channels, h_image, width * channels);

    // Free GPU and CPU memory
    cudaFree(d_image);
    cudaFreeHost(h_image); // Free pinned memory
    cudaFree(histogram);
    cudaFree(histogram_accumulated);
    cudaFree(histogram_equalized);
    stbi_image_free(image);

    return 0;
}
